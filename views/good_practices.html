<p>
  <a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion (DI)</a>
  isn't rocket science. We just need to try to avoid <code>new</code> and
  <code>singleton</code> except when there's a compelling reason to
  use them, such as a utility method that has no external
  dependencies, or a utility class that could not possibly have any
  purpose outside the framework (interop wrappers and dictionary
  keys are common examples of this).
</p>
<p>
  Many of the problems with IoC frameworks come up when developers
  are first learning how to use them, and instead of actually
  changing the way they handle dependencies and abstractions to fit
  the IoC model, instead try to manipulate the IoC container to meet
  the expectations of their old coding style, which would often
  involve high coupling and low cohesion.
</p>
<ul>
  <li>
      <h4>Use a Composition Root to avoid the Service Locator anti-pattern</h4>
      <p>
        Our application dependency tree should have one unique
        root element (known as the application composition root) which
        is the only component where we should invoke the resolve method.
      </p>
      <p>
        Invoking resolve every time we need to inject something, as if it was a
        <a href="http://en.wikipedia.org/wiki/Service_locator_pattern">Service Locator</a>
        is an anti-pattern. If we are working with an MVC framework
        the composition root should be located in the application class,
        somewhere along the routing logic or in a controller factory class.
      </p>
  </li>
  <li>
      <h4>Avoid Constructor over-injection</h4>
      <p>
        Constructor over-injection is a violation of the
        <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>.
        Too many constructor arguments indicates too many
        dependencies; too many dependencies indicates that the class
        is trying to do too much. Usually this error correlates with
        other code smells, such as unusually long or
        ambiguous ("manager") class names.
      </p>
  </li>
  <li>
      <h4>Avoid the injection of data, as opposed to behaviour</h4>
      <p>
        Injection of data, as opposed to behaviour, is a subtype of
        the <a href="http://en.wikipedia.org/wiki/Poltergeist_%28computer_science%29">poltergeist</a>
        anti-pattern. If a class needs to be aware of the current date
        and time, you don't inject a <code>DateTime</code>, which is
        data; instead, you inject an abstraction over the system
        clock. This is not only correct for DI; it is absolutely
        essential for testability, so that you can test time-varying
        functions without needing to actually wait on them.
      </p>
  </li>
  <li>
      <h4>Avoid declaring every life cycle as Singleton</h4>
      <p>
        Declaring every life cycle as Singleton is, to me, a
        perfect example of <a href="http://en.wikipedia.org/wiki/Cargo_cult_programming">cargo cult programming</a>
        and to a lesser degree the colloquially-named
        <a href="http://en.wikipedia.org/wiki/Object_cesspool#Pitfalls">object cesspool</a>.
        I've seen more singleton abuse than I care to remember, and
        very little of it involves DI.
      </p>
  </li>
  <li>
      <h4>Avoid implementation-specific interface types</h4>
      <p>
        Another common error is implementation-specific interface types done just to be able
        to register it in the container. This is in and of itself a violation of the
        <a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion Principle</a>
        (just because it's an interface, does not mean it's truly abstract) and often also includes
        <a href="http://en.wikipedia.org/wiki/Interface_bloat">interface bloat</a> which violates the
        <a href="http://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation Principle</a>.
      </p>
  </li>
  <li>
      <h4>Avoid optional dependencies</h4>
      <p>
        In other words, there is a constructor that accepts dependency injection, but
        also <em>another</em> constructor that uses a "default" implementation.
        This also violates the DIP and tends to lead to
        <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">LSP</a>
        violations as well, as developers, over time, start making assumptions around
        the default implementation, and/or start new-ing up instances using the default
        constructor.
      </p>
  </li>
</ul>
